function [ExternalForcesComputationResults] = ExternalForcesPrediction(filename, AnalysisParameters, BiomechanicalModel, ModelParameters)
% Prediction of ground reaction forces
%   Ground reaction forces are predicted from motion data.
%
%	Based on :
%	- Fluit, R., Andersen, M. S., Kolk, S., Verdonschot, N., & Koopman, H. F., 2014.
%	Prediction of ground reaction forces and moments during various activities of daily living. Journal of biomechanics, 47(10), 2321-2329.
%	- Skals, S., Jung, M. K., Damsgaard, M., & Andersen, M. S., 2017. 
%	Prediction of ground reaction forces and moments during sports-related movements. Multibody system dynamics, 39(3), 175-195.
%
%   INPUT
%   - filename: name of the file to process (character string)
%   - AnalysisParameters: parameters of the musculoskeletal analysis,
%   automatically generated by the graphic interface 'Analysis' 
%   - BiomechanicalModel: musculoskeletal model
%   - ModelParameters: parameters of the musculoskeletal model, automatically
%   generated by the graphic interface 'GenerateParameters' 
%   OUTPUT
%   - ExternalForcesComputationResults: results of the external forces
%   computation (see the Documentation for the structure)
%________________________________________________________
%
% Licence
% Toolbox distributed under 3-Clause BSD License
%________________________________________________________

disp(['External Forces Prediction (' filename ') ...'])

%% Chargement des variables
Human_model = BiomechanicalModel.OsteoArticularModel;
load([filename '/InverseKinematicsResults.mat']); %#ok<LOAD>
q = InverseKinematicsResults.JointCoordinates';
q6dof = InverseKinematicsResults.FreeJointCoordinates';
load([filename '/ExperimentalData.mat']); %#ok<LOAD>
time = ExperimentalData.Time;

freq=1/time(2);

%% Création de la structure Prédiction contenant les points de contact
%% Creation of a structure to add contact points
for i=1:numel(AnalysisParameters.Prediction.ContactPoint)
    Prediction(i).points_prediction_efforts = AnalysisParameters.Prediction.ContactPoint{i};
end
Prediction=verif_Prediction_Humanmodel(Human_model,Prediction);
NbPointsPrediction = numel(Prediction);

%% Gravité (gravity)
g=[0 0 -9.81]';

%% On enlève la liaison 6 ddl ajoutée par la cinématique inverse
%% get rid of the 6DOF joint
Human_model=Human_model(1:(numel(Human_model)-6));

%% Définition des vitesses / accélérations articulaires
% Speed and acceleration for every joint
dt=1/freq;
dq=derivee2(dt,q);  % vitesses
ddq=derivee2(dt,dq);  % accélérations

nbframe=size(q,1);

%% Définition des données cinématiques du pelvis
% (position / vitesse / accélération / orientation / vitesse angulaire / accélération angulaire)
% Kinematical data for Pelvis (Position/speed/acceleration/angles/angular speed/angular acceleration)

p_pelvis=q6dof(:,1:3);  % frame i : p_pelvis(i,:)
r_pelvis=cell(size(q6dof,1),1);
for i=1:size(q6dof,1)
    r_pelvis{i}=Rodrigues([1 0 0]',q6dof(i,4))*Rodrigues([0 1 0]',q6dof(i,5))*Rodrigues([0 0 1]',q6dof(i,6)); % matrice de rotation en fonction des rotations successives (x,y,z) : frame i : r_pelvis{i}
end

%dR
dR=zeros(3,3,nbframe);
for ligne=1:3
    for colonne=1:3
        dR(ligne,colonne,:)=derivee2(dt,cell2mat(cellfun(@(b) b(ligne,colonne),r_pelvis,'UniformOutput',false)));
        dR(ligne,colonne,:)=derivee2(dt,cell2mat(cellfun(@(b) b(ligne,colonne),r_pelvis,'UniformOutput',false)));
        dR(ligne,colonne,:)=derivee2(dt,cell2mat(cellfun(@(b) b(ligne,colonne),r_pelvis,'UniformOutput',false)));
    end
end
w=zeros(nbframe,3);
for i=1:nbframe
    wmat=dR(:,:,i)*r_pelvis{i}';
    w(i,:)=[wmat(3,2),wmat(1,3),wmat(2,1)];
end

% v0
v=derivee2(dt,p_pelvis);
vw=zeros(nbframe,3);
for i=1:nbframe
    vw(i,:)=cross(p_pelvis(i,:),w(i,:));
end
v0=v+vw;

% dv0
dv0=derivee2(dt,v0);

% dw
dw=derivee2(dt,w);

%% Initialisations des différents efforts et leur stockage
for f=1:nbframe
    for n=1:numel(Human_model)
        external_forces_pred(f).fext(n).fext=zeros(3,2);
        %external_forces_pred_opti(n).fext=zeros(3,2); % decommenter lors de l'usage de l'optimisation non-linéaire (uncomment this line if using non-linear optimisation)
    end
end

for pred = 1:NbPointsPrediction
    Prediction(pred).efforts_max=zeros(nbframe,3);
    Prediction(pred).efforts = zeros(nbframe,1);
end
Fx=zeros(NbPointsPrediction,nbframe);
Fy=zeros(NbPointsPrediction,nbframe);
Fz=zeros(NbPointsPrediction,nbframe);

% Detect(1).points_prediction_efforts='Rfootenlair';
% Detect(2).points_prediction_efforts='Lfootenlair';
% Detect(1).exist=0;
% Detect(2).exist=0;
% for f=1:nbframe
%     Detect(find(strcmp({Detect.points_prediction_efforts},'Rfootenlair'))).ptsdetect(f)=0; %#ok<FNDSB>
%     Detect(find(strcmp({Detect.points_prediction_efforts},'Lfootenlair'))).ptsdetect(f)=0; %#ok<FNDSB>
% end

%% Paramètres de l'optimisation fmincon pour probleme non-lineaire, minimisation des X^n
%% Parameters of fmincon for non linear optimisation of X^n
% X0= 1*ones(3*numel(Prediction),1);
% A=[];
% b=[];
% lb=-ones(3*numel(Prediction),1);
% lb(2*numel(Prediction)+1:3*numel(Prediction))=0;
% ub=ones(3*numel(Prediction),1);
%
% %options = optimoptions(@fmincon,'Algorithm','sqp','Display','off','GradObj','off','PlotFcns',@optimplotfval,'GradConstr','off','TolFun',1e-6,'TolX',1e-6);
% options = optimoptions(@fmincon,'Algorithm','sqp','Display','off','GradObj','off','GradConstr','off','TolFun',1e-6,'TolX',1e-6);

%% Paramètres de l'optimisation fmincon pour probleme lineaire
X0= 1*zeros(3*NbPointsPrediction,1);
lb=-ones(3*NbPointsPrediction,1);
lb(2*NbPointsPrediction+1:3*NbPointsPrediction)=0;
ub=ones(3*NbPointsPrediction,1);
lb_init=lb; ub_init=ub;

options = optimoptions(@fmincon,'Algorithm','sqp','Display','off','GradObj','off','GradConstr','off','TolFun',1e-6,'TolX',1e-6);

%% Calcul frame par frame
h = waitbar(0,['External Forces Prediction (' filename ')']);
for i=1:nbframe
    %attribution à chaque articulation de la position/vitesse/accélération (position/speed/acceleration for each joint)
    Human_model(1).p=p_pelvis(i,:)';
    Human_model(1).R=r_pelvis{i};
    Human_model(1).v0=v0(i,:)';
    Human_model(1).w=w(i,:)';
    Human_model(1).dv0=dv0(i,:)';
    Human_model(1).dw=dw(i,:)';
    for j=2:numel(Human_model)
        Human_model(j).q=q(i,j); %#ok<*SAGROW>
        Human_model(j).dq=dq(i,j);
        Human_model(j).ddq=ddq(i,j);
    end
    % Calcul positions / vitesses / accélération de chaque solide (computation of position/speed/acceleration for each solid)
    [Human_model,Prediction] = ForwardAllKinematicsPrediction(Human_model,Prediction,1); 
%     cptG=0;
%     cptD=0;
    %% Calcul des efforts maximaux disponibles (computation of maximum available effort)
    for pred = 1:numel(Prediction)
        Prediction(pred).px(i)=Prediction(pred).pos_anim(1);
        Prediction(pred).py(i)=Prediction(pred).pos_anim(2);
        Prediction(pred).pz(i)=Prediction(pred).pos_anim(3);
        Prediction(pred).vitesse_temps(i)=sqrt(Prediction(pred).vitesse(1,:)^2+Prediction(pred).vitesse(2,:)^2+Prediction(pred).vitesse(3,:)^2); % Recuperation de la norme de la vitesse (repère monde)
            Cpi = Force_max_TOR(Prediction(pred).pz(i),Prediction(pred).vitesse_temps(i),ModelParameters.Mass, AnalysisParameters.Prediction.PositionThreshold  , AnalysisParameters.Prediction.VelocityThreshold);
            Fx(pred,i)=Cpi;
            Fy(pred,i)=Cpi;
            Fz(pred,i)=Cpi;
            Prediction(pred).efforts_max(i,1)=Cpi; %Fx
            Prediction(pred).efforts_max(i,2)=Cpi; %Fy
            Prediction(pred).efforts_max(i,3)=Cpi; %Fz
    end
    Fmax=[Fx(:,i)' Fy(:,i)' Fz(:,i)'];
    
    %% Optimisation directe
    %% Linearisation de la condition dynamique
    %% Direct optimisation by linearization of the dynamical condition.
    A=zeros(6,3*numel(Prediction));
    b1=[0 0 0]';
    b2=[0 0 0]';
    
    [~,b1,b2]=InverseDynamicsSolid_lin(Human_model,g,1,b1,b2);
    bf=b1;
    bt=b2+cross(-p_pelvis(i,:)',b1); %on ramene les couples au niveau du pelvis (torques are expressed at pelvis point)
    b=[bf' bt']';
    
    for k = 1:numel(Prediction)
        % calcul des efforts
        A(1,k)=Prediction(k).efforts_max(i,1);
        A(2,k+numel(Prediction))=Prediction(k).efforts_max(i,2);
        A(3,k+2*numel(Prediction))=Prediction(k).efforts_max(i,3);
        % calcul des moments
        A(4,k+numel(Prediction))=-(Prediction(k).pz(i)-p_pelvis(i,3))*Prediction(k).efforts_max(i,2); %-pz*beta
        A(4,k+2*numel(Prediction))=(Prediction(k).py(i)-p_pelvis(i,2))*Prediction(k).efforts_max(i,3); %py*gamma
        A(5,k)=(Prediction(k).pz(i)-p_pelvis(i,3))*Prediction(k).efforts_max(i,1); %pz*alpha
        A(5,k+2*numel(Prediction))=-(Prediction(k).px(i)-p_pelvis(i,1))*Prediction(k).efforts_max(i,3); %-px*gamma
        A(6,k)=-(Prediction(k).py(i)-p_pelvis(i,2))*Prediction(k).efforts_max(i,1); %-py*alpha
        A(6,k+numel(Prediction))=(Prediction(k).px(i)-p_pelvis(i,1))*Prediction(k).efforts_max(i,2); %px*beta
    end
    
    
    %% Prise en compte du frottement: Pour chaque ponctuelle, |Fx|<0.5|Fz| et |Fy|<0.5|Fz|
    %% taking friction into account for every point to point link, |Fx|<0.5|Fz| et |Fy|<0.5|Fz|
    Afric=zeros(4*numel(Prediction),3*numel(Prediction));
    bfric=zeros(4*numel(Prediction),1);
    
    coef_friction = AnalysisParameters.Prediction.FrictionCoef;

    for k = 1:(numel(Prediction))
        Afric(k,k)=1*Prediction(k).efforts_max(i,1);
        Afric(k+numel(Prediction),k+numel(Prediction))=1*Prediction(k).efforts_max(i,2);
        Afric(k,k+2*numel(Prediction))=-coef_friction*Prediction(k).efforts_max(i,3);
        Afric(k+numel(Prediction),k+2*numel(Prediction))=-coef_friction*Prediction(k).efforts_max(i,2);
        Afric(k+2*numel(Prediction),k)=-1*Prediction(k).efforts_max(i,1);
        Afric(k+3*numel(Prediction),k+numel(Prediction))=-1*Prediction(k).efforts_max(i,2);
        Afric(k+2*numel(Prediction),k+2*numel(Prediction))=-coef_friction*Prediction(k).efforts_max(i,3);
        Afric(k+3*numel(Prediction),k+2*numel(Prediction))=-coef_friction*Prediction(k).efforts_max(i,3);
    end
    
    %% Minimisation de la somme des efforts normalisés pour chaque ponctuelle,
    % tout en respectant la dynamique et les frottements
    %% Minimizing sum of normalized efforts for each punctual joint while respecting dynamical equations and friction
    X = fmincon(@(X) sum(X.^2),X0,Afric,bfric,A,b,lb,ub,[],options);
    
    %% Optimisation de la prochaine minimisation
    lb=max(X-0.45,lb_init); %expérimentalement, les bornes ne varient pas de plus ou moins 0.45 (experimentaly, boundaries vary not more than 0.45)
    ub=min(X+0.45,ub_init);

    X0=X; %d'une frame à l'autre, on change très peu de position, donc de valeur d'effort (
    
    %% Récupération des forces finales, stockées d'abord dans Prediction (Final forces storage without prediction)
    for k = 1:numel(Prediction)
        Prediction(k).efforts(i,1)=X(k)*Prediction(k).efforts_max(i,1);
        Prediction(k).efforts(i,2)=X(k+numel(Prediction))*Prediction(k).efforts_max(i,2);
        Prediction(k).efforts(i,3)=X(k+2*numel(Prediction))*Prediction(k).efforts_max(i,1);
    end
    
    %% Optimisation non linéaire
    % Non utilisée car la linéaire marche bien
    %
    %     X = fmincon(@(X) sum(X.^2),X0,A,b,[],[],lb,ub,@(X) respect_dynamique(X,Human_model,Prediction,Fmax,external_forces_pred_opti,i),options);
    %     X0=X;
    %     tic
    %     [~,ceq(:,i)]=respect_dynamique(X,Human_model,Prediction,Fmax,external_forces_pred_opti,i);
    
    %% Calcul des efforts extérieurs tels qu’utilisés par la suite pour la dynamique
    %% Computation of external forces for use with dynamics
    external_forces_pred=addForces_Prediction_frame_par_frame(X,external_forces_pred,Prediction,Fmax,i);
    
    %% Distinction utilisation Kinect ou modèle normal: on ne recherche les efforts que sous les pieds
    %% distinction between Kinect or normal model: just look for effort under the feet
%     if Parameters.Markers_set(1)==4

%         Solid_name1='RShank';
%         SolidR=find(strcmp({Human_model.name},Solid_name1));   % numéro de ce solide (solid number)
%         
%         Solid_name2='LShank';
%         SolidL=find(strcmp({Human_model.name},Solid_name2));   % numéro de ce solide (solid number)
%     else
%         Solid_name1='RFoot';
%         SolidR=find(strcmp({Human_model.name},Solid_name1));   % numéro de ce solide (solid number)
%         
%         Solid_name2='LFoot';
%         SolidL=find(strcmp({Human_model.name},Solid_name2));   % numéro de ce solide (solid number)
%     end
    
    %% Stockage des forces (forces storage)

%     force_pied_droit_pred(i).Fx=external_forces_pred(i).fext(SolidR).fext(1,1);
%     force_pied_droit_pred(i).Fy=external_forces_pred(i).fext(SolidR).fext(2,1);
%     force_pied_droit_pred(i).Fz=external_forces_pred(i).fext(SolidR).fext(3,1);
%     force_pied_droit_pred(i).Mx=external_forces_pred(i).fext(SolidR).fext(1,2);
%     force_pied_droit_pred(i).My=external_forces_pred(i).fext(SolidR).fext(2,2);
%     force_pied_droit_pred(i).Mz=external_forces_pred(i).fext(SolidR).fext(3,2);
%     
%     force_pied_gauche_pred(i).Fx=external_forces_pred(i).fext(SolidL).fext(1,1);
%     force_pied_gauche_pred(i).Fy=external_forces_pred(i).fext(SolidL).fext(2,1);
%     force_pied_gauche_pred(i).Fz=external_forces_pred(i).fext(SolidL).fext(3,1);
%     force_pied_gauche_pred(i).Mx=external_forces_pred(i).fext(SolidL).fext(1,2);
%     force_pied_gauche_pred(i).My=external_forces_pred(i).fext(SolidL).fext(2,2);
%     force_pied_gauche_pred(i).Mz=external_forces_pred(i).fext(SolidL).fext(3,2);
  
    waitbar(i/nbframe)
end

close(h)
disp(['... External Forces Prediction (' filename ') done'])

%% Donnees filtrees comme la plateforme (filtered data)
%     f_mocap=1/time(2);
% 
%     force_pied_droit_pred_filt.Fx=filt_data([force_pied_droit_pred.Fx]',5,f_mocap);
%     force_pied_droit_pred_filt.Fy=filt_data([force_pied_droit_pred.Fy]',5,f_mocap);
%     force_pied_droit_pred_filt.Fz=filt_data([force_pied_droit_pred.Fz]',5,f_mocap);
%     force_pied_droit_pred_filt.Mx=filt_data([force_pied_droit_pred.Mx]',5,f_mocap);
%     force_pied_droit_pred_filt.My=filt_data([force_pied_droit_pred.My]',5,f_mocap);
%     force_pied_droit_pred_filt.Mz=filt_data([force_pied_droit_pred.Mz]',5,f_mocap);
%     
%     force_pied_gauche_pred_filt.Fx=filt_data([force_pied_gauche_pred.Fx]',5,f_mocap);
%     force_pied_gauche_pred_filt.Fy=filt_data([force_pied_gauche_pred.Fy]',5,f_mocap);
%     force_pied_gauche_pred_filt.Fz=filt_data([force_pied_gauche_pred.Fz]',5,f_mocap);
%     force_pied_gauche_pred_filt.Mx=filt_data([force_pied_gauche_pred.Mx]',5,f_mocap);
%     force_pied_gauche_pred_filt.My=filt_data([force_pied_gauche_pred.My]',5,f_mocap);
%     force_pied_gauche_pred_filt.Mz=filt_data([force_pied_gauche_pred.Mz]',5,f_mocap);
%     
%     for f=1:numel(time)
%         external_forces_pred(f).fext(SolidR).fext(1,1)=force_pied_droit_pred_filt.Fx(f);
%         external_forces_pred(f).fext(SolidR).fext(2,1)=force_pied_droit_pred_filt.Fy(f);
%         external_forces_pred(f).fext(SolidR).fext(3,1)=force_pied_droit_pred_filt.Fz(f);
%         external_forces_pred(f).fext(SolidR).fext(1,2)=force_pied_droit_pred_filt.Mx(f);
%         external_forces_pred(f).fext(SolidR).fext(2,2)=force_pied_droit_pred_filt.My(f);
%         external_forces_pred(f).fext(SolidR).fext(3,2)=force_pied_droit_pred_filt.Mz(f);
%         
%         external_forces_pred(f).fext(SolidL).fext(1,1)=force_pied_gauche_pred_filt.Fx(f);
%         external_forces_pred(f).fext(SolidL).fext(2,1)=force_pied_gauche_pred_filt.Fy(f);
%         external_forces_pred(f).fext(SolidL).fext(3,1)=force_pied_gauche_pred_filt.Fz(f);
%         external_forces_pred(f).fext(SolidL).fext(1,2)=force_pied_gauche_pred_filt.Mx(f);
%         external_forces_pred(f).fext(SolidL).fext(2,2)=force_pied_gauche_pred_filt.My(f);
%         external_forces_pred(f).fext(SolidL).fext(3,2)=force_pied_gauche_pred_filt.Mz(f);
%     end

%% Filtrage des données

if AnalysisParameters.Prediction.FilterActive
    f_cut = AnalysisParameters.Prediction.FilterCutOff;
    % Conversion sous la forme d'une matrice (conversion into a matrix)
    for i=1:numel(external_forces_pred)
        for j=1:numel(external_forces_pred(i).fext)
            PredictionFx(i,j) = external_forces_pred(i).fext(j).fext(1,1);
            PredictionFy(i,j) = external_forces_pred(i).fext(j).fext(2,1);
            PredictionFz(i,j) = external_forces_pred(i).fext(j).fext(3,1);
            PredictionMx(i,j) = external_forces_pred(i).fext(j).fext(1,2);
            PredictionMy(i,j) = external_forces_pred(i).fext(j).fext(2,2);
            PredictionMz(i,j) = external_forces_pred(i).fext(j).fext(3,2);
        end
    end
    % Filtrage
    PredictionFiltFx = filt_data(PredictionFx,f_cut,freq);
    PredictionFiltFy = filt_data(PredictionFy,f_cut,freq);
    PredictionFiltFz = filt_data(PredictionFz,f_cut,freq);
    PredictionFiltMx = filt_data(PredictionMx,f_cut,freq);
    PredictionFiltMy = filt_data(PredictionMy,f_cut,freq);
    PredictionFiltMz = filt_data(PredictionMz,f_cut,freq);
    % Remise sous la forme d'une structure (utilisée pour la dynamique inverse) (definition of a structure used for inverse dynamics)
    for i=1:numel(external_forces_pred)
        for j=1:numel(external_forces_pred(i).fext)
            external_forces_pred(i).fext(j).fext(1,1)=PredictionFiltFx(i,j);
            external_forces_pred(i).fext(j).fext(2,1)=PredictionFiltFy(i,j);
            external_forces_pred(i).fext(j).fext(3,1)=PredictionFiltFz(i,j);
            external_forces_pred(i).fext(j).fext(1,2)=PredictionFiltMx(i,j);
            external_forces_pred(i).fext(j).fext(2,2)=PredictionFiltMy(i,j);
            external_forces_pred(i).fext(j).fext(3,2)=PredictionFiltMz(i,j);
        end
    end
end

%% Pour animation (for animation purpose)

if ~any(strcmp('Visual',fieldnames(external_forces_pred)))
    external_forces_pred(1).Visual=[];
end
for f=1:numel(external_forces_pred) % pour chaque frame (for every frame)
    for i=unique([Prediction.num_solid]) % pour chaque solide (for every solid)
        T = external_forces_pred(f).fext(i).fext;
        % Position du centre de pression
        CoP = cross(T(:,1),T(:,2))/(norm(T(:,1))^2);
        CoP = CoP - (CoP(3)/T(3,1))*T(:,1); % point sur l'axe avec z=0
        % Remplissage de la structure external_forces
        external_forces_pred(f).Visual = [external_forces_pred(f).Visual [CoP;T(:,1)]];
    end
end

%% Récupération des données dans une matrice (extraction of data)

% for f=1:numel(external_forces_pred)
%     EffortsPred1(:,f) = external_forces_pred(f).Visual(:,1); %#ok<*SAGROW>
%     EffortsPred2(:,f) = external_forces_pred(f).Visual(:,2);
% end
% for i=1:numel(EffortsPred1)
%     if isnan(EffortsPred1(i))
%         EffortsPred1(i)=0;
%     end
% end
% for i=1:numel(EffortsPred2)
%     if isnan(EffortsPred2(i))
%         EffortsPred2(i)=0;
%     end
% end

%% Sauvegarde des données (data saving)

if exist([filename '/ExternalForcesComputationResults.mat'],'file')
    load([filename '/ExternalForcesComputationResults.mat']);
end
ExternalForcesComputationResults.ExternalForcesPrediction = external_forces_pred;

end