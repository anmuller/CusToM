<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of GeometricalCalibration</title>
  <meta name="keywords" content="GeometricalCalibration">
  <meta name="description" content="Calibration of the geometrical parameters">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html Functions --><!-- ../menu.html Calibration --><!-- menu.html Geometrical -->
<h1>GeometricalCalibration
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Calibration of the geometrical parameters</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [Human_model_calib, calib_parameters, Markers_set] = GeometricalCalibration(OsteoArticularModel, Markers_set, AnalysisParameters) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Calibration of the geometrical parameters
   Geometrical parameters (limbs length, local markers position and axis
   of rotation) are subject-specific calibrated from motion capture data.

   Associated publication:
    - Muller, A., Germain, C., Pontonnier, C., Dumont, G., 2015. 
    A Simple Method to Calibrate Kinematical Invariants: Application to Overhead Throwing. Int. Soc. Biomech. Sport. 2�5.

   Based on:
    - Reinbolt, J.A., Schutte, J.F., Fregly, B.J., Koh, B. Il, Haftka, R.T., George, A.D., Mitchell, K.H., 2005. 
    Determination of patient-specific multi-joint kinematic models through two-level optimization. J. Biomech. 38, 621�626.
    - Andersen, M.S., Damsgaard, M., MacWilliams, B., Rasmussen, J., 2010. 
    A computationally efficient optimisation-based method for parameter identification of kinematically determinate and over-determinate biomechanical systems. Comput. Methods Biomech. Biomed. Engin. 13, 171�183.

   INPUT
   - OsteoArticularModel: osteo-articular model (see the Documentation for
   the structure);
   - Markers_set: markers set (see the Documentation for the structure);
   - AnalysisParameters: parameters of the musculoskeletal analysis,
   automatically generated by the graphic interface 'Analysis'.
   OUTPUT
   - Human_model_calib: subject-specific calibrated osteo-articular model
   (see the Documentation for the structure);
   - calib_parameters: geometrical calibration results;
   - Markers_set: subject-specific calibrated markers set (see the
   Documentation for the structure).
________________________________________________________

 Licence
 Toolbox distributed under GPL 3.0 Licence
________________________________________________________

 Authors : Antoine Muller, Charles Pontonnier, Pierre Puchaud and
 Georges Dumont
________________________________________________________</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../Functions/AlgoMathsModel/Rodrigues.html" class="code" title="function R = Rodrigues(a,q)">Rodrigues</a>	Computation of the Rodrigues equation</li><li><a href="ClosedLoopCalib.html" class="code" title="function [c,ceq] = ClosedLoopCalib(Pelvis_position,Pelvis_rotation,q,k,pcut,Rcut,nb_ClosedLoop) %#ok<*INUSL>">ClosedLoopCalib</a>	Non-linear equation used in the geometrical calibration step for closed loops</li><li><a href="CostFunctionSymbolicCalib.html" class="code" title="function [error] = CostFunctionSymbolicCalib(q,k,Human_model,real_markers,f,list_function,list_function_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">CostFunctionSymbolicCalib</a>	Cost function used for the geometrical calibration step</li><li><a href="ErrorMarkersCalib.html" class="code" title="function [error] = ErrorMarkersCalib(q,k,Human_model,real_markers,f,list_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">ErrorMarkersCalib</a>	Computation of reconstruction error for the geometrical calibration</li><li><a href="OptCalibrationSymbolic.html" class="code" title="function [error] = OptCalibrationSymbolic(q,k,Human_model,real_markers,nb_frame,list_function,list_function_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">OptCalibrationSymbolic</a>	Cost function used for the calibration of the geometrical parameters</li><li><a href="SymbolicFunctionGeneration_A.html" class="code" title="function [Human_model,nbClosedLoop,Generalized_Coordinates,nb_k,k_map,nb_p,p_map,nb_alpha,alpha_map,A_norm,b_norm]=SymbolicFunctionGeneration_A(Human_model, Markers_set)">SymbolicFunctionGeneration_A</a>	Generation of symbolic function containing the position of markers according to joint coordinates and geometrical parameters</li><li><a href="../../../Functions/Kinematics/Add6dof.html" class="code" title="function [Human_model] = Add6dof(Human_model)">Add6dof</a>	Addition of a 6 dof joint</li><li><a href="../../../Functions/Pretraitement/Get_real_markers_Calibration.html" class="code" title="function [real_markers, nb_frames]=Get_real_markers_Calibration(filename,list_markers, AnalysisParameters)">Get_real_markers_Calibration</a>	Extraction of motion data for the geometrical calibration</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../Functions/Calibration/CalibrateModelGeneration.html" class="code" title="function [] = CalibrateModelGeneration(ModelParameters,AnalysisParameters)">CalibrateModelGeneration</a>	Generation of the calibrated musculoskeletal model</li><li><a href="../../../Functions/Calibration/CalibrateModelGenerationNum.html" class="code" title="function [] = CalibrateModelGenerationNum(ModelParameters,AnalysisParameters)">CalibrateModelGenerationNum</a>	Generation of the calibrated musculoskeletal model</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Human_model_calib, calib_parameters, Markers_set] = GeometricalCalibration(OsteoArticularModel, Markers_set, AnalysisParameters)</a>
0002 <span class="comment">% Calibration of the geometrical parameters</span>
0003 <span class="comment">%   Geometrical parameters (limbs length, local markers position and axis</span>
0004 <span class="comment">%   of rotation) are subject-specific calibrated from motion capture data.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%   Associated publication:</span>
0007 <span class="comment">%    - Muller, A., Germain, C., Pontonnier, C., Dumont, G., 2015.</span>
0008 <span class="comment">%    A Simple Method to Calibrate Kinematical Invariants: Application to Overhead Throwing. Int. Soc. Biomech. Sport. 2�5.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%   Based on:</span>
0011 <span class="comment">%    - Reinbolt, J.A., Schutte, J.F., Fregly, B.J., Koh, B. Il, Haftka, R.T., George, A.D., Mitchell, K.H., 2005.</span>
0012 <span class="comment">%    Determination of patient-specific multi-joint kinematic models through two-level optimization. J. Biomech. 38, 621�626.</span>
0013 <span class="comment">%    - Andersen, M.S., Damsgaard, M., MacWilliams, B., Rasmussen, J., 2010.</span>
0014 <span class="comment">%    A computationally efficient optimisation-based method for parameter identification of kinematically determinate and over-determinate biomechanical systems. Comput. Methods Biomech. Biomed. Engin. 13, 171�183.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   INPUT</span>
0017 <span class="comment">%   - OsteoArticularModel: osteo-articular model (see the Documentation for</span>
0018 <span class="comment">%   the structure);</span>
0019 <span class="comment">%   - Markers_set: markers set (see the Documentation for the structure);</span>
0020 <span class="comment">%   - AnalysisParameters: parameters of the musculoskeletal analysis,</span>
0021 <span class="comment">%   automatically generated by the graphic interface 'Analysis'.</span>
0022 <span class="comment">%   OUTPUT</span>
0023 <span class="comment">%   - Human_model_calib: subject-specific calibrated osteo-articular model</span>
0024 <span class="comment">%   (see the Documentation for the structure);</span>
0025 <span class="comment">%   - calib_parameters: geometrical calibration results;</span>
0026 <span class="comment">%   - Markers_set: subject-specific calibrated markers set (see the</span>
0027 <span class="comment">%   Documentation for the structure).</span>
0028 <span class="comment">%________________________________________________________</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% Licence</span>
0031 <span class="comment">% Toolbox distributed under GPL 3.0 Licence</span>
0032 <span class="comment">%________________________________________________________</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% Authors : Antoine Muller, Charles Pontonnier, Pierre Puchaud and</span>
0035 <span class="comment">% Georges Dumont</span>
0036 <span class="comment">%________________________________________________________</span>
0037 
0038 <span class="comment">%% Model save</span>
0039 Human_model_save=OsteoArticularModel;
0040 
0041 <span class="comment">%% Taking into account of constraints specified in AnalysisParameters</span>
0042 solid_names={OsteoArticularModel.name};
0043 <span class="comment">% k</span>
0044 <span class="keyword">for</span> i = 1:size(AnalysisParameters.CalibIK.LengthDelete,1)
0045     [~,~,num_solid] = intersect(AnalysisParameters.CalibIK.LengthDelete{i,1},solid_names);
0046     OsteoArticularModel(num_solid).calib_k_constraint = [];
0047 <span class="keyword">end</span>
0048 <span class="keyword">for</span> i = 1:size(AnalysisParameters.CalibIK.LengthAdd,1)
0049     [~,~,num_solid1] = intersect(AnalysisParameters.CalibIK.LengthAdd{i,1},solid_names);
0050     [~,~,num_solid2] = intersect(AnalysisParameters.CalibIK.LengthAdd{i,2},solid_names);
0051     OsteoArticularModel(num_solid1).calib_k_constraint = num_solid2;
0052 <span class="keyword">end</span>
0053 <span class="comment">% v</span>
0054 <span class="keyword">for</span> i=1:size(AnalysisParameters.CalibIK.AxisDelete,1)
0055     [~,~,num_solid] = intersect(AnalysisParameters.CalibIK.AxisDelete{i,1},solid_names);
0056 <span class="comment">%     OsteoArticularModel(num_solid).v = setdiff(OsteoArticularModel(num_solid).v',AnalysisParameters.CalibIK.AxisDelete{i,2}','rows')';</span>
0057     OsteoArticularModel(num_solid).v=[];
0058 <span class="keyword">end</span>
0059 <span class="keyword">for</span> i=1:size(AnalysisParameters.CalibIK.AxisAdd,1)
0060     [~,~,num_solid] = intersect(AnalysisParameters.CalibIK.AxisAdd{i,1},solid_names);
0061     OsteoArticularModel(num_solid).v = [OsteoArticularModel(num_solid).v AnalysisParameters.CalibIK.AxisAdd{i,2}]; 
0062 <span class="keyword">end</span>
0063 <span class="comment">% Markers</span>
0064 <span class="keyword">for</span> i=1:size(AnalysisParameters.CalibIK.MarkersCalibModif,1)
0065     [~,~,num_solid] = intersect(AnalysisParameters.CalibIK.MarkersCalibModif{i,1},{Markers_set.name});
0066     Markers_set(num_solid).calib_dir = AnalysisParameters.CalibIK.MarkersCalibModif{i,2};
0067 <span class="keyword">end</span>
0068 
0069 <span class="comment">%% Adding 6 DOF joint (pelvis to world)</span>
0070 [OsteoArticularModel] = <a href="../../../Functions/Kinematics/Add6dof.html" class="code" title="function [Human_model] = Add6dof(Human_model)">Add6dof</a>(OsteoArticularModel);
0071 s_root=find([OsteoArticularModel.mother]==0); <span class="comment">%#ok&lt;NASGU&gt; % num�o du solide root</span>
0072 
0073 <span class="comment">%% Symbolical function generation</span>
0074 <span class="comment">% Markers position according to the joint coordinates</span>
0075 [OsteoArticularModel,nbClosedLoop,GC,nb_k,k_map,nb_p,p_map,nb_alpha,alpha_map,A_norm,b_norm]=<a href="SymbolicFunctionGeneration_A.html" class="code" title="function [Human_model,nbClosedLoop,Generalized_Coordinates,nb_k,k_map,nb_p,p_map,nb_alpha,alpha_map,A_norm,b_norm]=SymbolicFunctionGeneration_A(Human_model, Markers_set)">SymbolicFunctionGeneration_A</a>(OsteoArticularModel, Markers_set);
0076 
0077 <span class="comment">%% list of markers from the model</span>
0078 list_markers={};
0079 <span class="keyword">for</span> i=1:numel(Markers_set)
0080     <span class="keyword">if</span> Markers_set(i).exist
0081         list_markers=[list_markers;Markers_set(i).name]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0082     <span class="keyword">end</span>
0083 <span class="keyword">end</span>
0084 nb_markers=size(list_markers,1);
0085 nb_solid=size(OsteoArticularModel,2);  <span class="comment">% nb de solides (number of solids)</span>
0086 
0087 <span class="comment">%% Real markers position from C3D file</span>
0088 filename = AnalysisParameters.CalibIK.filename;
0089 [real_markers, nb_frame]=<a href="../../../Functions/Pretraitement/Get_real_markers_Calibration.html" class="code" title="function [real_markers, nb_frames]=Get_real_markers_Calibration(filename,list_markers, AnalysisParameters)">Get_real_markers_Calibration</a>(filename,list_markers, AnalysisParameters);
0090 
0091 <span class="comment">%% Selection/choice of frame sample</span>
0092 nb_frame_calib = AnalysisParameters.CalibIK.Frames.NbFrames;
0093 [frame_calib] = AnalysisParameters.CalibIK.Frames.Method(nb_frame_calib, real_markers, list_markers);
0094 
0095 calib_parameters.frame_calib = frame_calib;
0096 <span class="comment">% Frame to use for calibration</span>
0097 real_markers_calib=struct;
0098 <span class="keyword">for</span> i=1:numel(real_markers)
0099     real_markers_calib(i).name=real_markers(i).name;
0100     real_markers_calib(i).position=real_markers(i).position(frame_calib,:);
0101 <span class="keyword">end</span>
0102 
0103 <span class="comment">%% Root position</span>
0104 Base_position=cell(nb_frame,1);
0105 Base_rotation=cell(nb_frame,1);
0106 <span class="keyword">for</span> i=1:nb_frame
0107     Base_position{i}=zeros(3,1);
0108     Base_rotation{i}=eye(3,3);
0109 <span class="keyword">end</span>
0110 
0111 <span class="comment">%% Initializations</span>
0112 taille = nb_k+nb_p+nb_alpha;
0113 
0114 k_init=zeros(taille,1);
0115 
0116 Nb_qred=size(GC.q_red,1);
0117 <span class="comment">% linear constraints for inverse kinemeatics, same joint angles for two</span>
0118 <span class="comment">% joints</span>
0119 Aeq_ik=zeros(Nb_qred);  
0120 beq_ik=zeros(Nb_qred,1);
0121 solid_red = (GC.q_map'*[1:nb_solid]')';
0122 <span class="keyword">for</span> i=1:length(solid_red)
0123     jj=solid_red(i);
0124     <span class="keyword">if</span> size(OsteoArticularModel(jj).linear_constraint) ~= [0 0] <span class="comment">%#ok&lt;BDSCA&gt;</span>
0125         Aeq_ik(i,i)=-1;
0126         ind_col = OsteoArticularModel(jj).linear_constraint(1,1);
0127         [~,c]=find(GC.q_map(ind_col,:));
0128         
0129         ind_val = OsteoArticularModel(jj).linear_constraint(2,1);
0130         [~,cc]=find(GC.q_map(ind_val,:));
0131         Aeq_ik(i,c)=cc;
0132     <span class="keyword">end</span>
0133 <span class="keyword">end</span>
0134 <span class="comment">% Aeq_ik=zeros(nb_solid);</span>
0135 <span class="comment">% beq_ik=zeros(nb_solid,1);</span>
0136 <span class="comment">% for i=1:nb_solid</span>
0137 <span class="comment">%     if size(OsteoArticularModel(i).linear_constraint) ~= [0 0] %#ok&lt;BDSCA&gt;</span>
0138 <span class="comment">%         Aeq_ik(i,i)=-1;</span>
0139 <span class="comment">%         Aeq_ik(i,OsteoArticularModel(i).linear_constraint(1,1))=OsteoArticularModel(i).linear_constraint(2,1);</span>
0140 <span class="comment">%     end</span>
0141 <span class="comment">% end</span>
0142 
0143 <span class="comment">%% Inverse kinematics</span>
0144 
0145 <span class="comment">% options = optimoptions(@fmincon,'Algorithm','interior-point','Display','iter-detailed','PlotFcns',@optimplotfval,'TolFun',1e-2,'MaxFunEvals',20000);</span>
0146 options = optimoptions(@fmincon,<span class="string">'Algorithm'</span>,<span class="string">'interior-point'</span>,<span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'TolFun'</span>,1e-2,<span class="string">'MaxFunEvals'</span>,20000);
0147 
0148 q_value{1}=zeros(Nb_qred,nb_frame_calib);
0149 
0150 addpath(<span class="string">'Symbolic_function'</span>)
0151 
0152 Rcut=zeros(3,3,max([OsteoArticularModel.KinematicsCut]));  
0153 pcut=zeros(3,1,max([OsteoArticularModel.KinematicsCut]));
0154 
0155 <span class="comment">% Functions list for computing cost function</span>
0156 list_function=cell(max([OsteoArticularModel.KinematicsCut]),1);
0157 <span class="keyword">for</span> c=1:max([OsteoArticularModel.KinematicsCut])
0158     list_function{c}=str2func(sprintf(<span class="string">'f%dcut'</span>,c));
0159 <span class="keyword">end</span>
0160 list_function_markers=cell(numel(list_markers),1);
0161 <span class="keyword">for</span> m=1:numel(list_markers)
0162     list_function_markers{m}=str2func(sprintf([list_markers{m} <span class="string">'_Position'</span>]));
0163 <span class="keyword">end</span>
0164 
0165 <span class="comment">% Joint limits</span>
0166 q_map=GC.q_map;
0167 l_inf=[OsteoArticularModel.limit_inf]';
0168 l_sup=[OsteoArticularModel.limit_sup]';
0169 <span class="comment">% to handle infinity</span>
0170 ind_infinf=not(isfinite(l_inf));
0171 ind_infsup=not(isfinite(l_sup));
0172 <span class="comment">% tip to handle inflinity with a complex number.</span>
0173 l_inf(ind_infinf)=1i;
0174 l_sup(ind_infsup)=1i;
0175 <span class="comment">% new indexing</span>
0176 l_inf=q_map'*l_inf;
0177 l_sup=q_map'*l_sup;
0178 <span class="comment">%find 1i to replay by inf</span>
0179 l_inf(l_inf==1i)=-inf;
0180 l_sup(l_sup==1i)=+inf;
0181 
0182 
0183 <span class="keyword">for</span> f=1:nb_frame_calib
0184     <span class="keyword">if</span> f == 1      <span class="comment">% initial frame</span>
0185         q0=zeros(Nb_qred,1);
0186     <span class="keyword">else</span>
0187         q0=q_value{1}(:,f-1);
0188     <span class="keyword">end</span>
0189     ik_function_objective=@(qvar)<a href="CostFunctionSymbolicCalib.html" class="code" title="function [error] = CostFunctionSymbolicCalib(q,k,Human_model,real_markers,f,list_function,list_function_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">CostFunctionSymbolicCalib</a>(qvar,k_init,OsteoArticularModel,real_markers_calib,f,list_function,list_function_markers,Base_position{f},Base_rotation{f},Rcut,pcut);
0190     nonlcon=@(qvar)<a href="ClosedLoopCalib.html" class="code" title="function [c,ceq] = ClosedLoopCalib(Pelvis_position,Pelvis_rotation,q,k,pcut,Rcut,nb_ClosedLoop) %#ok<*INUSL>">ClosedLoopCalib</a>(Base_position{f},Base_rotation{f},qvar,k_init,pcut,Rcut,nbClosedLoop); <span class="comment">% pas tester</span>
0191     [q_value{1}(:,f)] = fmincon(ik_function_objective,q0,[],[],Aeq_ik,beq_ik,l_inf,l_sup,nonlcon,options);
0192 <span class="keyword">end</span>
0193 
0194 <span class="comment">% Error computation</span>
0195 errorm{1}=zeros(numel(list_markers),nb_frame_calib);
0196 <span class="keyword">for</span> f=1:nb_frame_calib
0197     [errorm{1}(:,f)] = <a href="ErrorMarkersCalib.html" class="code" title="function [error] = ErrorMarkersCalib(q,k,Human_model,real_markers,f,list_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">ErrorMarkersCalib</a>(q_value{1}(:,f),k_init,OsteoArticularModel,real_markers_calib,f,list_markers,Base_position{f},Base_rotation{f},Rcut,pcut);
0198 <span class="keyword">end</span>
0199 
0200 <span class="comment">%% Calibration</span>
0201 
0202 <span class="comment">% Optimization constraints for calibration</span>
0203 Aeq_calib=zeros(taille);
0204 beq_calib=zeros(taille,1);
0205 
0206 <span class="comment">% Constraints for k</span>
0207 <span class="keyword">for</span> i=1:nb_solid-6
0208     <span class="keyword">if</span> size(OsteoArticularModel(i).calib_k_constraint) ~= [0 0]
0209             vect2map = zeros(nb_solid,1);
0210             vect2map(i,1) = 1;
0211             cur_ind_k = find(k_map'*vect2map==1);
0212 <span class="comment">%         if OsteoArticularModel(i).calib_k_constraint == 0</span>
0213 <span class="comment">%             Aeq_calib(cur_ind_k,cur_ind_k)=1;</span>
0214 <span class="comment">%             beq_calib(cur_ind_k,1)=-1;</span>
0215 <span class="comment">%         else</span>
0216             vect2map = zeros(nb_solid,1);
0217             vect2map(OsteoArticularModel(i).calib_k_constraint,1) = 1;
0218             ind_k_map_constraint = k_map'*vect2map==1;
0219             Aeq_calib(cur_ind_k,cur_ind_k)=1;
0220             Aeq_calib(cur_ind_k,ind_k_map_constraint)=-1;
0221 <span class="comment">%         end</span>
0222     <span class="keyword">end</span>
0223 <span class="keyword">end</span>
0224 
0225 <span class="comment">%% Boundaries for setting variation limits</span>
0226 limit_inf_calib = -ones(taille,1); 
0227 limit_sup_calib = ones(taille,1); 
0228 
0229 g=1;       
0230 crit(:,g)=1; <span class="comment">% stop criteria</span>
0231 
0232 kp_opt(:,g)=k_init;
0233 
0234 <span class="keyword">while</span> crit(:,g) &gt; 0.05
0235     
0236     <span class="comment">% Geometric parameters optimisation</span>
0237     pk_function_objective=@(kp)<a href="OptCalibrationSymbolic.html" class="code" title="function [error] = OptCalibrationSymbolic(q,k,Human_model,real_markers,nb_frame,list_function,list_function_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">OptCalibrationSymbolic</a>(<span class="keyword">...</span>
0238                           q_value{g},kp,<span class="keyword">...</span>
0239                           OsteoArticularModel,real_markers_calib,nb_frame_calib,list_function,list_function_markers,Base_position,Base_rotation,Rcut,pcut);
0240                       
0241     [kp_opt(:,g+1)] = fmincon(pk_function_objective,kp_opt(:,g),[],[],Aeq_calib,beq_calib,limit_inf_calib,limit_sup_calib,[],options);
0242     
0243     q_value{g+1}=zeros(size(q_value{g})); <span class="comment">%#ok&lt;AGROW&gt;</span>
0244     
0245     <span class="comment">% Articular coordinates optimisation</span>
0246     <span class="keyword">for</span> f=1:nb_frame_calib
0247         q0=q_value{g}(:,f);
0248         
0249         ik_function_objective=@(qvar)<a href="CostFunctionSymbolicCalib.html" class="code" title="function [error] = CostFunctionSymbolicCalib(q,k,Human_model,real_markers,f,list_function,list_function_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">CostFunctionSymbolicCalib</a>(<span class="keyword">...</span>
0250             qvar,kp_opt(:,g+1),<span class="keyword">...</span>
0251             OsteoArticularModel,real_markers_calib,f,list_function,list_function_markers,Base_position{f},Base_rotation{f},Rcut,pcut);
0252                             
0253         nonlcon=@(qvar)<a href="ClosedLoopCalib.html" class="code" title="function [c,ceq] = ClosedLoopCalib(Pelvis_position,Pelvis_rotation,q,k,pcut,Rcut,nb_ClosedLoop) %#ok<*INUSL>">ClosedLoopCalib</a>(Base_position{f},Base_rotation{f},qvar,<span class="keyword">...</span>
0254             kp_opt(:,g+1),<span class="keyword">...</span>
0255             pcut,Rcut,nbClosedLoop);
0256     
0257         [q_value{g+1}(:,f)] = fmincon(ik_function_objective,q0,[],[],Aeq_ik,beq_ik,l_inf,l_sup,nonlcon,options);
0258     <span class="keyword">end</span>
0259     
0260     <span class="comment">% Error computation</span>
0261     errorm{g+1}=zeros(numel(list_markers),nb_frame_calib); <span class="comment">%#ok&lt;AGROW&gt;</span>
0262     <span class="keyword">for</span> f=1:nb_frame_calib
0263         [errorm{g+1}(:,f)] = <a href="ErrorMarkersCalib.html" class="code" title="function [error] = ErrorMarkersCalib(q,k,Human_model,real_markers,f,list_markers,Pelvis_position,Pelvis_rotation,Rcut,pcut)">ErrorMarkersCalib</a>(q_value{g+1}(:,f),kp_opt(:,g+1),<span class="keyword">...</span>
0264             OsteoArticularModel,real_markers_calib,f,list_markers,Base_position{f},Base_rotation{f},Rcut,pcut);
0265     <span class="keyword">end</span>
0266     
0267     <span class="comment">% Stop criteria</span>
0268     crit(:,g+1)=abs(mean(mean(errorm{g+1}))-mean(mean(errorm{g})))/mean(mean(errorm{g}));
0269     
0270     g=g+1;
0271 <span class="keyword">end</span>
0272 calib_parameters.crit=crit;
0273 calib_parameters.errorm=errorm;
0274 
0275 <span class="comment">%% Recuperation of k, p and alpha</span>
0276 <span class="comment">% Normalization</span>
0277 kp_opt_unormalized=A_norm\(kp_opt(:,end)-b_norm);
0278 
0279 calib_parameters.k_calib=k_map*[kp_opt_unormalized(1:nb_k,end); 1];
0280 calib_parameters.p_calib=p_map*kp_opt_unormalized(nb_k+1:nb_k+nb_p,end);
0281 calib_parameters.alpha_calib=alpha_map*kp_opt_unormalized(nb_k+nb_p+1:taille,end);
0282 calib_parameters.alpha_calib=<span class="keyword">...</span>
0283 [calib_parameters.alpha_calib(1:2:length(calib_parameters.alpha_calib)),<span class="keyword">...</span>
0284 calib_parameters.alpha_calib(2:2:length(calib_parameters.alpha_calib))];
0285 
0286 <span class="comment">%% Model actualisation with obtained k and p values.</span>
0287 Human_model_calib=Human_model_save;
0288 <span class="comment">% k_calib %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0289 <span class="keyword">for</span> i=1:numel(Human_model_save)
0290     Human_model_calib(i).b=Human_model_save(i).b*calib_parameters.k_calib(OsteoArticularModel(i).mother); <span class="comment">% b (k de la m�e)</span>
0291     Human_model_calib(i).c=Human_model_save(i).c*calib_parameters.k_calib(i); <span class="comment">% c</span>
0292     Human_model_calib(i).I=Human_model_save(i).I*calib_parameters.k_calib(i); <span class="comment">% I</span>
0293     <span class="keyword">for</span> j=1:size(Human_model_save(i).anat_position,1)
0294         Human_model_calib(i).anat_position{j,2}=Human_model_save(i).anat_position{j,2}*calib_parameters.k_calib(i);
0295     <span class="keyword">end</span>
0296 <span class="keyword">end</span>
0297 <span class="comment">% p_calib %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0298 m=0;
0299 <span class="keyword">for</span> i=1:numel(Markers_set)
0300     <span class="keyword">if</span> Markers_set(i).exist
0301         m=m+1;
0302         Human_model_calib(Markers_set(i).num_solid).anat_position{Markers_set(i).num_markers,2} = <span class="keyword">...</span>
0303             Human_model_calib(Markers_set(i).num_solid).anat_position{Markers_set(i).num_markers,2} + <span class="keyword">...</span>
0304             calib_parameters.p_calib((3*(m-1)+1):(3*m),:)*calib_parameters.k_calib(Markers_set(i).num_solid);
0305     <span class="keyword">end</span>
0306 <span class="keyword">end</span>
0307 <span class="comment">% alpha_calib %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0308 <span class="keyword">if</span> nb_alpha
0309     <span class="keyword">for</span> j=1:numel(Human_model_save)
0310         <span class="keyword">if</span> ~isempty(Human_model_calib(j).v)
0311             alpha_j=calib_parameters.alpha_calib(j,:);
0312             Human_model_calib(j).a = <a href="../../../Functions/AlgoMathsModel/Rodrigues.html" class="code" title="function R = Rodrigues(a,q)">Rodrigues</a>(Human_model_calib(j).v(:,2),alpha_j(2))*<a href="../../../Functions/AlgoMathsModel/Rodrigues.html" class="code" title="function R = Rodrigues(a,q)">Rodrigues</a>(Human_model_calib(j).v(:,1),alpha_j(1))*Human_model_calib(j).a;
0313         <span class="keyword">end</span>
0314     <span class="keyword">end</span>
0315 <span class="keyword">end</span>
0316 
0317 <span class="comment">% kinematic dependancy %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0318 <span class="keyword">if</span> size(GC.q_dep,1)&gt;0
0319     vect_q_dep = GC.q_dep_map*GC.fq_dep_k(GC.q_red , kp_opt_unormalized(1:nb_k,end));
0320     vect_k_dep = GC.q_dep_map*GC.ind_k_dep;
0321     <span class="keyword">for</span> j=1:numel(Human_model_save)
0322         <span class="keyword">if</span> isfield(Human_model_calib,<span class="string">'kinematic_dependancy'</span>) &amp;&amp; ~isempty(Human_model_calib(j).kinematic_dependancy)
0323                  Human_model_calib(j).kinematic_dependancy.q=matlabFunction(vect_q_dep(j));
0324 <span class="comment">%                  if vect_k_dep(j)~=0</span>
0325 <span class="comment">%                     Human_model_calib(j).kinematic_dependancy.numerical_estimates(:,2)=...</span>
0326 <span class="comment">%                         calib_parameters.k_calib(vect_k_dep(j))*Human_model_calib(j).kinematic_dependancy.numerical_estimates(:,2);</span>
0327 <span class="comment">%                  end</span>
0328         <span class="keyword">end</span>
0329     <span class="keyword">end</span>
0330 <span class="keyword">end</span>
0331 
0332 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0333 <span class="comment">%% Symbolical fonction suppression</span>
0334 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0335 rmpath(<span class="string">'Symbolic_function'</span>)
0336 rmdir(<span class="string">'Symbolic_function'</span>,<span class="string">'s'</span>)
0337 
0338 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 28-Apr-2021 14:02:00 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>